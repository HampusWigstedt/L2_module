# Code Quality Reflection

## Meaningful Names

| Name and explination | Reflection |
|----------------------|----------|
| **Convert**  Class name for mp4 -> mp3 convertion           |   **Avoid Disinformation:** The Converter class may be interpreted as a class that can convert files in general(wich is the main idea in the end) it only converts a mp4 file to a mp3 file in testing cases. A more meaningful name would be Mp4ToMp3 or ConvertToMp3.      |
|      **ext** Variable name in Server.js                |   **Use Pronounceable and Searchable Names:** ext is a variable for holdin the name extension of a file when we use extname method from the path package to easily get the file name extension of a file. To make this name more readable and searchable extensionName or fileExtension could have been used.      |
|      **filePath** Parameter name for method convertToMp3                |    **Make Meaningful Distinctions:** This is a bit of a reach but i still think its a important analysis. filepath is the path to the file that we want to convert, which most times would be an alright name. The problem is that we also take in the parameter **utputFilePath** which specifes where the file should be sent. I would say the name inputFilePath would be way more non-trivial, to quote the book.     |
|     **deleteAllFiles** Method name in FileDeleter class                |  **Avoid Disinformation:** I think the issue with the naming is pretty self explanitory if you read the file name before the method name. The method deletes the temp files stored on the server when changing/converting the files. The easy fix would be renaming the method to deleteTempFiles. deleteAllFiles is very disinformative.        |
|           **resize** Method in VideoResizer class          |  **Use Intention-Revealing Names:** I think the naming of this method is pretty vague. We do explain the intent of the method but what are we really resizeing? We could resize everything from file size to duration. I think naming this method changeResolution or ChangeVideoDimension would be more descriptive of the methods intent.       |

## Reflection Chapter 2
> I would say im pretty good at naming my code for the most part. There are more occasions of me getting stuck trying to figure out a name for somthing then the opposite. The biggest things i will take with me in my coding is **Use Intention-Revealing Names.** When i code i, like most other programmers, have a vision in my head over the system and how it works. So in my head it's obvious that the method resize() will change the resolution size of a video as that is the only resizeing im doing in the current state of the program. Same goes for deleteAllFiles(). I don't have much to criticize in this chapter. It's great to reflect on things like naming that, in the grand scheme feel like small issues but could become bigger problems when we colaborate or when we further develop our programs.
>

## Functions

| Name of method | Ammount of lines and link | Reflection |
|----------|----------|----------|
| **handleRemoveAudio**         |  [Code](https://github.com/HampusWigstedt/L2_module/blob/main/handlers.js) 27 lines       |  **Small functions:** As this is the largest method in the program i think this fits well. I don't fully agree with the book regarding this rule. It is stated that "Function should hardly ever be 20 lines long" which i think is harsh and i think HandleRemoveAudio is a good example. The methods purpose is to handle the order and flow of methods that will complete the task of removing audio from a file and there is also some error handling in this method. I would argue that this is a totaly fine amount of code for a method in a class that serves as the main connection between the clients requests and the servers serving. But don't get me wrong. 5-10 more lines and its too much in my opinion aswell.        |
|  **handleStereoToSurround**        |   [Code](https://github.com/HampusWigstedt/L2_module/blob/main/handlers.js) 23 lines       | **Do One Thing:** This method breaks the rule of a method only doing on thing. The purpose of the method is to handle the connection between the clients request and the servers serving. So in this case i don't see a huge problem with the method doing multiple things. I like the implementation as it is and in my opinion, breaking the method into smaller methods would decrease readability. I could see the handler class being seperated inte handler classes for each action. So that handleStereoToSurround would be a class with 3 methods or so.       |
|   **resize**       |   [Code](https://github.com/HampusWigstedt/L2_module/blob/main/resizeVideo.js) 23 lines       |  **Command-Query Separation:** The method executes resizing and reports erros and results in the same method. This violates CQS as it 1.resizes the video and 2. returns success/erros state. The better approach would be to have a function that performs the resizing and another function that handles the success/failure reporting.       |
|   **removeAudio**       |   [Code](https://github.com/HampusWigstedt/L2_module/blob/main/ClientCode/client.js) 22 lines       |  **DRY:** Don't repeat yourself is somthing that we have heard since the day i began coding and i think this method shows that i still have problems following it. Most of the methods in the Client class are the same with small differences as the api calls are for different routes and some file are handled differently. This should not be a reason to copy and paste code. We should have one method for api calls and load parameters into it. Plain and simple.         |
|    **resizeVideo**      |     [Code](https://github.com/HampusWigstedt/L2_module/blob/main/ClientCode/client.js) 21 lines     |  **Do One Thing:** This function Prepares the API request, makes an API call, Saves the resized video and handles errors, breaking the Do One Thing rule. Following the rule, the method should in my vision be broken down to 3 functions. One for preparing the formadata, one for making the API request and one for Saving the response to a file. Although this would be the best approach, with this code i wanted to have it all collected in one function so the readability would be easier for users who will implement and or chage the client code to fit their application.     |

## Reflection Chapter 3
> I think this chapter of the book has made me reflect way more over my own code then chapter two. I can't seem to find Seperation of concerns in the first chapters but i think it blends this whole chapter together. Having small functions, that do one thing and have the same level of abstraction are in my mind all seperations of concerns. When looking at my code i would say these rules are the primary problems for me and i will definently keep these rules in mind when making methods in the future. I have to dissagree with the rule that error handling should be seperated from the function. Try...catch is great but somtimes we write code without it. In these cases i would prefer if the error handling for that specific function is in that function. I would argue that having the error handling in the function increases readability by a mile. I also think Descriptive Names is crucial but i don't feel like that is a huge problem in my coding.

# Reflection

The reflection of naming and the long methods gave me a greater idea of ​​how to implement the rules of clean code in my own code. My reflection is that chapter 3 of the book could be boiled down to one thing. Methods should do one thing. By creating smaller methods that do one thing we can follow a lot of rules very easily. The functions get smaller **Small functions**, The method does only one thing **Do on thing** The method has the same, **level of abstraction**. By creating smaller methods we also follow Command-Query Separation and in the process, makes the code more reusable. As stated before in this reflection i think by also implement separation of concerns, even tho it’s not stated in these chapters, we can create nice methods with good reusability that are also easy to read and understand. I will definitely keep these rules in mind when making methods in the future.

Reflecting on chapter one, i think my biggest takeaway is the importance of good naming in our code. I think the biggest part for me when reading code that i unknown to me is **Avoid Mental Mapping**. A simple method with parameters (a, b) could be so confusing compared to if we use (width, height). The first example doesn’t tell us anything about what we are actually using. Same goes for examples like (object1, object2) when we can write what the objects actually are (ProductInfoObject, ProductHistoryObject). Of course rules like **use intentional names** and **Searchable names** are very important as it is crucial for us programmers to understand the code. We could have a method named jjhjhafjkahuchh() and another method named jjhjhafjjkahuchh() and the IDE would still understand that these are 2 different methods. But as programmers we will have a hard time differentiating these methods.

In general i think the rules in the book are very good for the most part. When reflecting on whether or not our code should follow these rules there will always be a difference of how programmers want to write their code, but in the grand scheme of things i think the rules should be followed as they will help the programmer and the collaborators in the long run.
